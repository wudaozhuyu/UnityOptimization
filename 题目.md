## c# 匿名函数的内存是如何分配的
* 当您在C#中创建匿名函数时，它将被编译成一个闭包（closure）。闭包将函数本身与函数作用域中的变量捆绑在一起，以便在其它地方调用函数时，变量状态不会丢失。因此，在内存中，闭包将包含函数的内部代码和它所使用的所有变量的状态。闭包会在您调用匿名函数时分配内存，并在函数调用结束时被释放。

## socket底层
* Socket是一种基于传输层协议的应用程序接口，它提供了一种标准化的方式，使得应用程序可以通过网络进行通信。
 在底层实现中，Socket通常使用TCP或UDP协议进行数据传输。TCP协议是面向连接的，它提供了可靠的数据传输机制，确保数据传输的顺序和完整性。UDP协议则是无连接的，它提供了一种快速的数据传输方式，但不保证数据传输的顺序和完整性。
 当建立一个Socket连接时，首先需要创建一个Socket对象。这个对象包含了一些基本的属性，如IP地址、端口号、传输协议等。然后，就需要使用Socket对象来连接另一个Socket对象，以建立起一条数据通道。
 在建立连接后，Socket对象可以使用不同的方法来进行数据的发送和接收。对于TCP连接，Socket通常使用输入输出流（InputStream和OutputStream）来进行数据的读写。对于UDP连接，Socket通常使用DatagramPacket和DatagramSocket对象来进行数据的传输。
 总之，Socket底层实现的核心是基于TCP或UDP协议的数据传输。它为应用程序提供了一种标准化的网络通信接口，使得开发者可以轻松地实现网络通信功能。

 ## 帧同步
 * 帧同步是一种多人在线游戏中常用的网络同步方式，其主要是指将游戏服务器和客户端之间的游戏状态进行同步。在帧同步模式下，服务器将游戏状态划分为若干个时间片，每个时间片称为一帧，服务器通过广播每一帧的状态信息给所有客户端，从而同步所有玩家的游戏状态。
 在帧同步中，需要同步的数据包括玩家的位置、朝向、状态、动作、攻击等游戏状态信息，同时还需要将玩家输入的指令同步给服务器，如移动、跳跃、攻击等，以保证服务器和客户端之间的游戏状态一致。
 此外，在帧同步中还需要对游戏状态进行压缩和优化，以减少网络传输的数据量，降低网络延迟和带宽占用。通常，服务器会对游戏状态进行预测，根据玩家的指令和当前的游戏状态估算未来的游戏状态，从而减少数据传输量，提高游戏的流畅度和稳定性。
 总之，帧同步主要同步的是玩家的游戏状态信息和输入指令，以保证所有玩家在同一时刻的游戏状态一致，从而实现多人在线游戏的正常运行。

 ## 状态同步
 * 状态同步是一种通过网络将游戏状态从服务器同步到客户端的技术。在状态同步中，服务器将游戏状态信息发送给客户端，以确保服务器和客户端之间的游戏状态保持一致。
 在状态同步中，需要同步的数据包括玩家的位置、状态、动作、朝向、血量、能量、装备等游戏状态信息。此外，还需要同步游戏世界中的其他实体信息，例如怪物的位置、状态、血量等。
 在实现状态同步时，通常采用一些优化技术，如状态压缩、状态预测等，以减少网络传输的数据量和延迟。例如，服务器可以对游戏状态进行预测，根据玩家的输入和当前的游戏状态估算未来的游戏状态，从而减少数据传输量，提高游戏的流畅度和稳定性。
 总之，状态同步主要同步游戏状态信息，以确保所有玩家在同一时刻的游戏状态保持一致，从而实现网络游戏的正常运行。

 ## 状态同步和帧同步区别
 * 状态同步和帧同步都是多人在线游戏中常用的网络同步方式，但是它们的实现方式和应用场景不同，具体区别如下：
 1. 同步方式不同
 状态同步是指将游戏状态从服务器同步到客户端，以确保服务器和客户端之间的游戏状态保持一致；而帧同步是将游戏状态划分为若干个时间片，每个时间片称为一帧，服务器通过广播每一帧的状态信息给所有客户端，从而同步所有玩家的游戏状态。
 2. 同步数据不同
 状态同步主要同步游戏状态信息，如玩家的位置、状态、血量等；而帧同步需要同步的数据除了游戏状态信息，还包括玩家的输入指令，如移动、攻击等。
 3. 应用场景不同
 状态同步适用于一些回合制和慢节奏的游戏，如策略游戏和角色扮演游戏，因为这些游戏的动作比较缓慢，可靠性要求较高，而且网络延迟对游戏影响不是很大。
 帧同步适用于一些动作类游戏，如射击游戏和竞技游戏，因为这些游戏的动作比较快速，玩家需要即时响应，所以网络延迟会对游戏影响较大，因此需要使用帧同步来保证游戏的流畅性和实时性。
 总之，状态同步和帧同步在多人在线游戏中扮演着不同的角色，并且都有其独特的应用场景。游戏开发者需要根据游戏的类型和玩家的需求来决定使用哪种同步方式。
 4. 状态同步和帧同步的本质区别在于同步的粒度不同。状态同步是以游戏状态为单位进行同步，而帧同步则是以时间帧（Frame）为单位进行同步。具体来说，它们的不同表现在以下几个方面：
 5. 同步的数据不同
 状态同步主要同步游戏状态信息，如玩家的位置、状态、血量等；而帧同步需要同步的数据除了游戏状态信息，还包括玩家的输入指令，如移动、攻击等。因为帧同步需要保证客户端和服务器的游戏状态完全一致，所以需要将玩家的输入指令也同步到客户端和服务器之间。
 6. 同步的时机不同
 状态同步是在状态发生变化时进行同步，如玩家移动了一格，那么服务器就需要将玩家的最新位置信息同步给所有客户端；而帧同步是每隔一定的时间间隔进行同步，如每秒钟同步60帧，即每隔16.6毫秒同步一次。
 7. 同步的延迟不同
 状态同步的延迟比帧同步要小，因为状态变化发生后就会立即同步，而帧同步需要等待一定的时间才进行同步。另外，帧同步的延迟还受到网络延迟的影响，如果网络延迟过大，就会产生明显的延迟和卡顿现象。
 综上所述，状态同步和帧同步适用于不同的游戏类型和场景，游戏开发者需要根据游戏的特点和玩家需求来选择合适的同步方式。

 ## UDP
 * UDP是用户数据报协议（User Datagram Protocol）的简称，是一种无连接的面向数据报的传输协议。相对于TCP协议，UDP有以下几个特点：
 1. 无连接：UDP在发送数据前不需要先建立连接，因此传输的速度更快，但也意味着传输的可靠性较差，容易发生数据丢失或乱序的情况。
 2. 数据报形式：UDP将数据和目标地址封装成数据报进行传输，每个数据报的大小限制在64KB以内，因此在传输大文件时需要进行分割。
 3. 低延迟：UDP不需要建立连接和等待确认，因此传输的延迟很低，适合需要实时性较高的应用场景，如语音、视频、游戏等。
 4. 不可靠：UDP不提供可靠的传输保障，因此如果数据包丢失、重复或乱序，应用程序需要自行处理，如采用冗余数据、确认重传等机制来保证数据的可靠性。
 5. 支持多播和广播：UDP支持多播和广播，能够将数据同时传输给多个目标地址。
 6. 简单轻量：UDP的头部较小，只有8个字节，相比TCP更为轻量级，适合用于嵌入式系统和移动设备等资源受限的场景。
 总的来说，UDP协议适合于对数据传输速度和实时性要求较高的场景，如视频、语音、游戏等应用。但是由于UDP协议存在不可靠性，因此在传输要求较高的应用场景中，需要通过其他方式来保证数据的可靠性，如冗余数据、确认重传等机制。

 ## KCP
 * KCP是一种快速可靠传输协议，是一个轻量级的协议，由著名网络专家鲁大师设计，主要用于网络游戏、实时音视频等对传输延时和丢包率要求较高的场景。和TCP和UDP不同的是，KCP使用了自己的传输协议，并对UDP键进行封装，从而实现了更快更可靠的传输效果。
 KCP的主要特点如下：
1. 快速：KCP主要通过减少流量控制的次数来减轻网络的负担，从而提高整体传输速度。
2. 可靠：KCP通过自己的前向纠错机制和重传机制来保证数据的可靠传输，有效地降低了因丢包而造成的传输错误。
3. 轻量级：KCP协议头部只有24字节，相比于TCP和UDP更为轻量级。
4. 低延迟：KCP以时间戳为基础，采用延迟折扣算法来保证数据的及时传输，实现了较低的传输延迟。
5. 支持流量控制：KCP通过限制发送端和接收端的窗口大小来实现流量控制，避免了网络拥塞和数据丢失等问题。
 总的来说，KCP在网络游戏、实时音视频等对传输时延和丢包率要求较高的场景下，具有明显的优势。它在保持TCP传输可靠性的同时，通过其自身的机制来减少网络负担、降低延迟和提高传输速度，是一种极具应用价值的传输协议。

 ## 为什么栈上内存申请比堆上内存申请快
 * 栈上内存申请比堆上内存申请快主要有两个原因：
 1. 内存管理方式不同：栈是由编译器自动管理的，而堆则是由程序员手动申请和释放的。对于栈上的内存申请，只需要移动栈指针即可完成，速度非常快。而堆上的内存申请需要进行更复杂的操作，比如查找可用内存块、分配内存等，所以速度相对较慢。
 2. 内存访问方式不同：栈上的内存访问是按照LIFO（后进先出）的顺序进行的，而堆上的内存访问则是随机访问的。由于现代计算机的内存是按照地址顺序存储的，所以按照顺序存储的栈上的内存访问效率要比随机存储的堆上的内存访问效率高。
 需要注意的是，栈上的内存大小是有限的，通常只有几MB，而堆上的内存大小则可以通过操作系统的调整来实现。因此，在使用栈和堆进行内存申请时，需要根据需求合理选择。对于需要动态申请大量内存的情况，堆是更合适的选择；而对于需要申请小规模内存且访问顺序比较固定的情况，栈则是更快的选择。

 ## Mask和RectMask2D的CPU开销的不同吗
 * Unity中的Mask和RectMask2D在CPU开销方面的表现略有不同。
 Mask是一个通用的掩码组件，使用Stencil Buffer实现，可以用于2D和3D场景。在使用Mask时，所有的相关物体都要经过深度测试和模板测试，因此在CPU上的开销比较大。尤其是在绘制大量物体的情况下，Mask的性能表现更为明显。
 RectMask2D是专门用于2D场景的掩码组件，使用Clipping实现，可以让一个UI元素只显示在一个矩形区域内。在使用RectMask2D时，在绘制UI元素时只需要计算被裁剪的UI元素即可，因此性能比Mask要好很多。
 总的来说，Mask的CPU开销比RectMask2D大，因为Mask使用了Stencil Buffer的深度测试和模板测试，而RectMask2D使用了Clipping进行UI元素的裁剪。但无论使用哪种掩码组件，都需要根据具体场景和需求选择合适的方案，避免影响性能。

## 哪些UIRebuild的Dirty类型
* 在Unity中，UI系统中的UGUI涉及到的UIRebuild的Dirty类型有以下几种：
 1. Transform：表示Transform中的某个属性发生了变化，需要重新计算UI布局和渲染。
 2. Layout：表示UI布局发生了变化，需要重新计算布局和渲染。
 3. Visual Elements：表示UI元素显示属性发生了变化，需要重新计算显示效果和渲染。
 4. Material：表示UI元素使用的材质发生了变化，需要重新计算材质和渲染。
 5. Texture：表示UI元素使用的纹理发生了变化，需要重新计算纹理和渲染。
 6. Font：表示UI元素使用的字体发生了变化，需要重新计算字体和渲染。
 7. RectTransform：表示RectTransform中的某个属性发生了变化，需要重新计算UI布局和渲染。
 以上是常用的UIRebuild的Dirty类型，不同类型的Dirty会触发不同的UIRebuild操作，从而保证UI的正确显示。需要注意的是，过于频繁的UIRebuild操作会影响性能，因此应该尽可能减少不必要的Dirty操作。

### 为什么不考虑直接在UGUI源码层做修改，直接在Dirty的时候记录整个堆栈？
* 在UGUI源码中记录整个堆栈信息，确实可以方便开发者定位UI相关问题，但是这种方式对性能和内存消耗都有很大的影响。原因如下：
1.性能问题：
在记录整个堆栈信息的过程中，需要频繁调用系统API，而这些API会带来一定的性能消耗。在UI更新频繁的场景下，这种影响会更加明显，可能会导致UI的卡顿、掉帧等问题。
2.内存问题：
整个堆栈信息占用的内存空间较大，如果频繁记录整个堆栈信息，会导致内存消耗过大，尤其是在移动端设备上。这可能会导致应用程序因为内存不足而被系统强制退出。
因此，为了保证UI的性能和稳定性，不建议在UGUI源码中记录整个堆栈信息。正确的做法是，在开发和测试过程中，使用专业的调试工具来快速定位UI问题，并进行优化和修复。保持UI界面清晰、简洁，避免出现过于复杂的UI布局，也可以有效避免UI相关问题的出现。

## 空间索引算法
* 空间索引算法是一种用于快速查询和处理空间数据的方法，它可以有效地提高空间数据处理的效率。空间索引算法通常分为静态算法和动态算法两种类型。
 静态算法主要用于处理静态的空间数据，其基本思想是将空间数据划分成多个较小的空间单元，然后将空间单元组织成一种数据结构，以便快速查询和处理。
 常见的静态空间索引算法包括：
1. Quadtree：将空间分成四个等分的正方形子区域，每个正方形子区域再递归地分成四个子区域。通过将空间划分为多个正方形子区域，可以快速定位和处理空间数据。
2. R-Tree：将空间划分成多个节点，每个节点对应着不同的空间区域。通过在树结构中逐层搜索，可以快速查找和处理相关的空间数据。
3. Grid Indexing：将空间划分成多个正方形格子，每个格子对应着不同的空间区域。通过将空间数据映射到相应的格子中，可以快速查询和处理。
 动态算法主要用于处理动态的空间数据，其基本思想是在静态索引算法的基础上进行优化。常见的动态空间索引算法包括：
1. KD-Tree：将空间分为多个分割的子空间，每个分割面都是垂直于坐标轴的。通过交替选择不同的坐标轴，可以逐层地构建KD-Tree，实现快速的空间数据查询和处理。
2. Octree：类似于Quadtree，但是将空间分成八个等分的立方体子区域，每个立方体子区域再递归地分成八个子区域。通过将空间划分为多个立方体子区域，可以更加准确地定位和处理空间数据。
3. BSP-Tree：将空间划分为不同的节点，每个节点表示一个面的一侧。通过逐层递归地构建BSP-Tree，可以实现快速的面查询和处理。
 空间索引算法的进一步优化，需要结合具体的应用场景和数据特点进行选择和调优。

 ## 堆内存和栈内存的区别
 * 在计算机内存管理中，堆和栈是两种最基本的数据结构，它们一般用于存储程序运行时创建的变量和对象。
 堆内存和栈内存的区别主要有以下几个方面：
 1. 内存分配方式：栈内存是通过系统栈来分配内存的，每次分配都会将栈指针向下移动；而堆内存则是通过运行时分配器（malloc或new）进行分配。
 2. 分配效率：堆内存的分配效率相对较低，因为需要通过动态内存管理算法进行内存分配；而栈内存的分配效率较高，因为只需要移动栈指针即可。
 3. 分配大小：栈内存的大小是固定的，一旦分配就无法改变，而堆内存的大小没有固定限制，可以根据需要进行动态分配。
 4. 生命周期：栈内存为自动分配和自动释放，因此变量的生命周期和函数的作用域相同；而堆内存的生命周期不受作用域限制，需要手动分配和释放，否则可能导致内存泄漏。
 综上所述，堆内存和栈内存的区别主要在内存分配方式、分配效率、分配大小和生命周期方面。在程序设计中，应根据具体情况选择堆内存或栈内存来存储变量和对象，以达到更好的性能和可靠性。

 ## unity Native内存和Managed内存间的区别
 * 在Human:Unity中，Native内存和Managed内存是两种不同的内存类型，区别如下：
1. Native内存：Native内存是指由操作系统分配的内存，也称为非托管内存。在Unity中，Native内存通常用于高性能的计算或者操作，比如渲染大型模型、解码媒体数据、音频处理等。Native内存由Unity的C++代码管理，可通过指针（IntPtr）操作，使用完后需要手动释放，否则可能导致内存泄漏或导致程序崩溃。
2. Managed内存：Managed内存是指由CLR（Common Language Runtime）管理的内存，也称为托管内存。在Unity中，Managed内存通常用于游戏逻辑、UI元素、脚本等业务逻辑的处理。Managed内存通常由Unity的C#的代码管理，不需要手动管理内存，CLR会进行自动垃圾回收，以避免内存泄漏和提高内存利用率。
 因此，在使用Unity开发游戏时，需要根据实际需求选择适当的内存类型。Native内存通常用于高性能计算，Managed内存适用于业务逻辑处理与游戏对象创建。同时，在开发过程中需要注意，Native内存操作可能会导致内存泄漏或崩溃等问题。

 ## 在Managed内存和Native内存上可以做哪方面的优化？
 * 在Managed内存和Native内存上可以进行不同的优化：
 1. Managed内存优化：
 - 使用对象池：在游戏中，有些对象会频繁地创建和销毁，这会导致大量的GC（Garbage Collection）造成性能问题。使用对象池可以避免频繁的GC，减少游戏卡顿。
- 避免使用大量的装箱操作：装箱操作会将值类型转换为引用类型，增加了内存开销，并且会触发GC。避免使用大量的装箱操作可以减少GC负担。
- 避免使用不必要的反射：在C#中，反射操作会启用JIT编译器并且会导致大量的GC，因此应该避免使用不必要的反射操作。
- 避免使用不必要的字符串拼接：字符串拼接会创建新的字符串对象，这会导致大量的GC。因此应该避免使用不必要的字符串拼接，可以使用StringBuilder来代替。
 2. Native内存优化：
 - 减少内存分配：Native内存通常需要手动分配和释放，过多的内存分配和释放会导致性能问题和内存碎片。因此应该尽可能地减少内存分配，使用对象池等方法来重用内存。
- 使用内存对齐：内存对齐可以减少内存碎片并且提高访问速度。
- 避免使用内存泄漏：Native内存使用完之后需要手动释放，因此应该避免使用内存泄漏，手动释放内存。
- 使用缓存优化：对于一些需要高性能的计算和操作，可以使用缓存来优化性能。
 总之，在Managed内存和Native内存上进行优化，可以提高程序的性能和减少内存开销，从而提升游戏的流畅度和用户体验。

 ## StringBuilder是如何实现的
 * StringBuilder是C#中的一个字符串处理类，它可以有效地构建和操作可变字符串（mutable string），可以避免在字符串操作时频繁地创建新的字符串对象，从而减少内存分配和GC的负担，提高应用程序的性能。
 StringBuilder类内部是通过一个动态数组（dynamic array）来存储字符串的，同时提供了一系列的方法来添加、删除、替换、插入等操作字符串。StringBuilder类也实现了IEnumerable<char>接口，所以可以直接使用foreach来迭代字符串。
 当向StringBuilder中添加字符串时，如果StringBuilder的内部动态数组已满，它会自动扩容，将当前数组长度乘以2，然后将原有的元素复制到新的数组中，从而避免了数组容量不足的问题。同时，为了进一步减少内存分配和提高性能，在创建StringBuilder时，可以指定一个初始容量（Capacity）来避免不必要的动态扩容。
 在实现上，StringBuilder类内部采用了一个char[]数组来存储字符串内容，通过当前字符串长度（Length）和StringBuilder的容量（Capacity）来判断是否需要进行数组扩容，同时提供了一系列的方法来向数组中添加、删除、替换、插入等操作字符串，相关的方法会根据当前字符串长度和容量计算出需要进行的数组操作，然后执行相应的操作。因此，StringBuilder类的添加、删除、替换、插入等操作都是在内部char[]数组上进行的，而不是创建新的字符串对象。这也是StringBuilder类具有高效性能的原因之一。

## unity垃圾回收
* Unity采用了基于标记-清除（Mark-and-sweep）算法的垃圾回收机制，其特点如下：
 1. 延迟回收：Unity的垃圾回收机制是一种延迟回收算法，即当分配的内存不足时，才会触发垃圾回收，因此可能会导致一定的内存浪费。
 2. 标记-清除：Unity使用标记-清除算法进行垃圾回收，该算法分为两个阶段：标记阶段和清除阶段。在标记阶段，程序会遍历所有对象，标记出所有仍在使用中的对象。在清除阶段，程序会清除所有未被标记的对象，并回收它们所占用的内存空间。
 3. 暂停程序：在进行垃圾回收时，Unity会暂停程序的执行，直到垃圾回收完成，因此可能会对程序的性能产生一定的影响。
 4. 给程序带来复杂性：由于垃圾回收机制是由Unity自身管理和维护的，因此可能导致一些潜在的问题，如内存分配、GC开销、内存泄漏等问题，这些问题需要通过开发者进行优化和调试。
 综上所述，Unity的垃圾回收算法的特点是采用基于标记-清除算法的延迟回收机制，需要暂停程序执行，给程序带来了一定的复杂性。

 ## CLR回收和Unity回收
* Unity采用的是Mono运行时环境，其内置的垃圾回收器主要是由Mono运行时环境的垃圾回收器和Unity自身的垃圾回收器组成，因此Unity会自己处理和回收一些对象，而其他对象则由CLR来回收。
下面是Unity和CLR各自回收的对象：
- Unity回收的对象：
 1. Unity对象：Unity创建的对象（如GameObject、Component等）由Unity自身的垃圾回收器进行回收。
 2. Asset对象：在使用AssetBundle、Resources等进行资源加载时，如果不再使用该资源，则其内存空间由Unity垃圾回收器进行回收。
 3. 动态分配内存：使用new操作符进行的内存分配，也由Unity垃圾回收器进行回收。
- CLR回收的对象：
 1. C#中创建的对象：C#代码创建的对象（如自定义类的实例等），由CLR的垃圾回收器进行回收。
 2. 非托管资源：非托管资源（如操作系统资源、COM+组件等）由CLR的垃圾回收器进行管理和回收。
 需要注意的是，在使用Mono和Unity开发时，由于Mono垃圾回收器和Unity垃圾回收器都在起作用，因此在内存分配和回收方面，需要开发者进行一些注意和调整，以优化程序性能和内存使用。

## 哪些寻路算法？
* 以下是常见的几种寻路算法：
1. Dijkstra算法：这是一种单源最短路径算法，通过求出起点到各个顶点的最短路径来进行寻路。它适用于没有负权边的有向图和无向图。
2. A*算法：在Dijkstra算法的基础上，A*算法引入了“启发式评价函数”，通过评估从当前节点到目标节点的估计距离来进行优化，以得到更快的路径寻找速度。因此，A*算法适用于带有启发信息（如估计距离）的对路径进行寻找。
3. Floyd算法：这是一种多源最短路径算法，它可以计算任意两个顶点之间的最短路径。它适用于复杂图或动态图寻路。
4. Bellman-Ford算法：这也是一种单源最短路径算法，它适用于任意有向图或无向图，并且可以处理负权边。
5. 迪克斯特拉算法：这也是一种单源最短路径算法，它通过贪心地选择从起点到当前节点距离最小的节点来进行寻路，并逐步扩展到所有节点。
 这些寻路算法各有优劣，适用的场景不同。在实际应用中，需要根据情况选择合适的算法。






